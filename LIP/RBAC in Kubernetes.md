There are a lot of parts about Kubernetes that are hard. Once everything is configured, compute resources are easier to scale in interesting ways, but getting there can be complicated. One of the more challenging aspects of Kubernetes is the idea of Roles and Role Based Access Control, or RBAC. When you first set up a kubernetes cluster, you will probably see a kubeconfig file that gives you the full Cluster Admin role. And while it is easy to share that kubeconfig with others, you really shouldn't. 

If everyone is a cluster admin, then anyone can do things they shouldn't. What can a cluster admin do? Well, everything from delete existing services and pods, or running processes that might be against company policy, all the way up to deleting nodes. Some of these actions could be intentional while others, perhaps most, are probably accidental. Once you are a cluster admin, its too easy to copy and paste a command that destroys your environment. And if your machine is compromised, the attacker can also do anything they like. 

The principle of least privilege says that a subject should be given only those privileges needed for it to complete its task. This applies to kubernetes just as much as it does to the operating system on your computer. But how do you give a user access to just the things they need in the cluster. Or how about giving an application just the rights it needs? Well, it turns out it is pretty simple

All you need is to define the user and the role and then bind the role to the user. The only problem is that there aren't really users in kubernetes... a user name is actually the common name of a certificate. So defining a user is as simple as generating a new certificate. But to generate that cert, you need to use the certificate and key of the certificate authority in the kubernetes cluster. So you will probably need a tool like openssl, because you aren't actually going to be able to do that with kubectl. And its not actually one command you need to run, because you actually need to start with a private key and then a certificate signing request, and then use that in conjunction with the CA to actually generate the certificate for the user. 

Then you need to build the kube config file so that starts by defining a cluster which includes  the public key of the certificate authority as well as the address of the api server. Then you need to add the credentials for the user which is really the certificate you generated. Then you need to add the context which links the cluster to the user. OK, so thatâ€™s not too hard, right? Oh, and you really should update the cert and thus the kubeconfig fairly often... 5 minutes is a good interval. Oh, and you are going to need to do this for all your users. 

And despite all those steps we have done, we have only created a user. If that user tries to do anything they will get an error since they aren't allowed to do anything yet. 

Now you need to create the roles and bind the roles to the user certificate. Defining roles is a bit easier. Your roles are going to be a collection of verbs and the resources those verbs apply to. The verbs you can include can be found in the chart on this page (https://kubernetes.io/docs/reference/access-authn-authz/authorization/#determine-the-request-verb). The resources can include any of the resources available in your cluster. 

So creating roles is relatively easy but users is a bit of a challenge. If however, you are using Infra, the user part is easy and linking the user to the role is just as easy. 

Lets take a look at the roles that are defined on this cluster. There are actually two types of roles in Kubernetes: Roles and ClusterRoles. Roles are defined per namespace and clusterroles are defined for the cluster. You can see that there are a lot of cluster roles defined for the system to function. You probably won't ever touch those. 