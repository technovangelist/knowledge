There are a lot of parts about Kubernetes that are hard. Once everything is configured, compute resources are easier to scale in interesting ways, but getting there can be complicated. One of the more challenging aspects of Kubernetes is the idea of Roles and Role Based Access Control, or RBAC. When you first set up a kubernetes cluster, you will probably see a kubeconfig file that gives you the full Cluster Admin role. And while it is easy to share that kubeconfig with others, you really shouldn't. 

If everyone is a cluster admin, then anyone can do things they shouldn't. What can a cluster admin do? Well, everything from delete existing services and pods, or running processes that might be against company policy, all the way up to deleting nodes. Some of these actions could be intentional while others, perhaps most, are probably accidental. Once you are a cluster admin, its too easy to copy and paste a command that destroys your environment. And if your machine is compromised, the attacker can also do anything they like. 

The principle of least privilege says that a subject should be given only those privileges needed for it to complete its task. This applies to kubernetes just as much as it does to the operating system on your computer. But how do you give a user access to just the things they need in the cluster. Or how about giving an application just the rights it needs? Well, it turns out it is pretty simple

All you need is to define the user and the role and then bind the role to the user. The only problem is that there aren't really users in kubernetes... a user name is actually the common name of a certificate. So defining a user is as simple as generating a new certificate. But to generate that cert, you need to use the certificate and key of the certificate authority in the kubernetes cluster. So you will probably need a tool like openssl, because you aren't actually going to be able to do that with kubectl. And its not actually one command you need to run, because you actually need to start with a private key and then a certificate signing request, and then use that in conjunction with the CA to actually generate the certificate for the user. 

Then you need to build the kube config file so that starts by defining a cluster which includes  the public key of the certificate authority as well as the address of the api server. Then you need to add a context